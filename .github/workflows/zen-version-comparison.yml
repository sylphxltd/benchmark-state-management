name: Zen Version Comparison

on:
  workflow_dispatch:
    inputs:
      versions:
        description: 'Comma-separated versions to test (leave empty for all)'
        required: false
        default: ''
      iterations:
        description: 'Number of iterations per version for stability'
        required: false
        default: '3'

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      version-matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set version matrix
        id: set-matrix
        run: |
          if [ -z "${{ github.event.inputs.versions }}" ]; then
            # All v3 versions from 3.1.0 onwards
            VERSIONS='["3.1.0","3.1.1","3.1.2","3.1.3","3.1.4","3.1.5","3.2.0","3.3.0","3.5.0","3.7.0","3.8.0","3.9.0","3.10.0","3.11.0","3.12.0","3.13.0","3.13.1","3.14.0","3.15.0","3.15.1","3.16.0","3.16.1","3.17.0","3.17.1","3.18.0","3.19.0","3.19.1","3.19.2","3.20.0","3.20.1","3.21.0","3.21.1","3.21.2","3.22.0","3.24.0","3.27.0","3.28.0","3.29.0","3.30.0","3.32.0","3.34.0","3.36.0","3.38.0","3.40.0","3.41.1","3.43.0","3.43.1","3.44.0","3.44.1","3.44.2","3.45.0","3.45.1","3.45.2","3.46.0","3.47.0","3.48.0"]'
          else
            # Convert comma-separated input to JSON array (compact output)
            VERSIONS=$(echo "${{ github.event.inputs.versions }}" | jq -Rc 'split(",") | map(gsub("^\\s+|\\s+$";""))')
          fi
          echo "matrix=$VERSIONS" >> $GITHUB_OUTPUT
          echo "Testing versions: $VERSIONS"

  benchmark-version:
    needs: prepare
    runs-on: ubuntu-latest
    strategy:
      matrix:
        version: ${{ fromJson(needs.prepare.outputs.version-matrix) }}
      max-parallel: 1  # Run sequentially for fairness
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: '1.3.2'  # Fixed version to avoid bun.sh outages

      - name: Set Zen version in package.json
        working-directory: benchmarks/state-management
        run: |
          echo "Setting Zen version to ${{ matrix.version }}"
          # Modify package.json to use specific version
          jq '.dependencies["@sylphx/zen"] = "${{ matrix.version }}"' package.json > package.json.tmp
          mv package.json.tmp package.json
          cat package.json | jq '.dependencies["@sylphx/zen"]'

      - name: Install dependencies
        working-directory: benchmarks/state-management
        run: |
          # Clean install to ensure correct version
          rm -rf node_modules package-lock.json
          npm install
          echo "Installation complete"

      - name: Verify Zen version
        working-directory: benchmarks/state-management
        run: |
          INSTALLED_VERSION=$(npm list @sylphx/zen --depth=0 --json | jq -r '.dependencies["@sylphx/zen"].version')
          echo "Installed version: $INSTALLED_VERSION"
          echo "Expected version: ${{ matrix.version }}"
          if [ "$INSTALLED_VERSION" != "${{ matrix.version }}" ]; then
            echo "❌ Error: Version mismatch!"
            exit 1
          fi
          echo "✅ Version verified"

      - name: Run benchmarks
        working-directory: benchmarks/state-management
        run: bun run benchmark
        timeout-minutes: 15

      - name: Upload results
        uses: actions/upload-artifact@v4
        with:
          name: results-${{ matrix.version }}
          path: benchmarks/state-management/results/zen/*.json
          retention-days: 30

  aggregate-results:
    needs: benchmark-version
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: '1.3.2'

      - name: Download all results
        uses: actions/download-artifact@v4
        with:
          path: collected-results

      - name: Aggregate and analyze results
        run: |
          cat > analyze.ts << 'EOF'
          import { readdirSync, readFileSync, writeFileSync } from 'fs';
          import { join } from 'path';

          interface BenchmarkResult {
            version: string;
            test: string;
            opsPerSecond: number;
            meanTime: number;
          }

          const resultsDir = 'collected-results';
          const results: Map<string, BenchmarkResult[]> = new Map();

          // Read all result files
          const artifacts = readdirSync(resultsDir);
          const resultsByTest: Map<string, Map<string, number>> = new Map();

          for (const artifact of artifacts) {
            const match = artifact.match(/results-(.+)$/);
            if (!match) continue;

            const version = match[1];
            const files = readdirSync(join(resultsDir, artifact));

            for (const file of files) {
              if (!file.endsWith('.json')) continue;

              const data = JSON.parse(
                readFileSync(join(resultsDir, artifact, file), 'utf-8')
              );

              const testName = data.test;
              if (!resultsByTest.has(testName)) {
                resultsByTest.set(testName, new Map());
              }

              resultsByTest.get(testName)!.set(version, data.result.opsPerSecond);
            }
          }

          // Convert to array format for reporting
          const byTest: Map<string, Array<{ version: string; opsPerSecond: number }>> = new Map();

          for (const [testName, versionResults] of resultsByTest.entries()) {
            const testData: Array<{ version: string; opsPerSecond: number }> = [];
            for (const [version, ops] of versionResults.entries()) {
              testData.push({ version, opsPerSecond: ops });
            }
            byTest.set(testName, testData);
          }

          // Generate markdown report
          let markdown = '# Zen Version Performance Comparison\n\n';
          markdown += `Generated: ${new Date().toISOString()}\n\n`;
          markdown += '## Key Tests\n\n';

          const keyTests = [
            'Single Read',
            'Single Write',
            'Batch Write (10x)',
            'Computed Value Access',
            'Deep Chain (10 layers)',
            'Very Deep Chain (100 layers)',
            'Wide Fanout (1→100)',
            'Massive Fanout (1→1000)'
          ];

          for (const test of keyTests) {
            const data = byTest.get(test);
            if (!data) continue;

            // Sort by opsPerSecond descending
            data.sort((a, b) => b.opsPerSecond - a.opsPerSecond);

            markdown += `### ${test}\n\n`;
            markdown += '| Rank | Version | Ops/sec | vs Best |\n';
            markdown += '|------|---------|---------|----------|\n';

            const best = data[0].opsPerSecond;
            data.slice(0, 10).forEach((item, idx) => {
              const pct = ((item.opsPerSecond / best) * 100).toFixed(1);
              const ops = item.opsPerSecond >= 1000000
                ? `${(item.opsPerSecond / 1000000).toFixed(2)}M`
                : item.opsPerSecond >= 1000
                ? `${(item.opsPerSecond / 1000).toFixed(0)}K`
                : item.opsPerSecond.toFixed(0);
              markdown += `| ${idx + 1} | ${item.version} | ${ops} | ${pct}% |\n`;
            });
            markdown += '\n';
          }

          // Summary table - find best version for each test
          markdown += '## Best Version by Test\n\n';
          markdown += '| Test | Best Version | Ops/sec |\n';
          markdown += '|------|--------------|----------|\n';

          for (const test of keyTests) {
            const data = byTest.get(test);
            if (!data) continue;
            const best = data.sort((a, b) => b.opsPerSecond - a.opsPerSecond)[0];
            const ops = best.opsPerSecond >= 1000000
              ? `${(best.opsPerSecond / 1000000).toFixed(2)}M`
              : best.opsPerSecond >= 1000
              ? `${(best.opsPerSecond / 1000).toFixed(0)}K`
              : best.opsPerSecond.toFixed(0);
            markdown += `| ${test} | **${best.version}** | ${ops} |\n`;
          }

          writeFileSync('VERSION_COMPARISON.md', markdown);
          console.log('Report generated: VERSION_COMPARISON.md');
          EOF

          bun run analyze.ts

      - name: Upload comparison report
        uses: actions/upload-artifact@v4
        with:
          name: version-comparison-report
          path: VERSION_COMPARISON.md

      - name: Comment on workflow run
        if: github.event_name == 'workflow_dispatch'
        run: |
          if [ -f VERSION_COMPARISON.md ]; then
            echo "## Version Comparison Report" >> $GITHUB_STEP_SUMMARY
            cat VERSION_COMPARISON.md >> $GITHUB_STEP_SUMMARY
          fi
