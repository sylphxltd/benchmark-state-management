#!/usr/bin/env node
/**
 * README Generator for Each Test Group
 * Creates individual README files for each test group
 */

const { readFileSync, writeFileSync, existsSync, mkdirSync } = require('fs');
const { join } = require('path');

class GroupReadmeGenerator {
  constructor(groupsPath) {
    this.groupsPath = groupsPath;
  }

  generateGroupReadme(groupName, groupNameDisplay) {
    const groupPath = join(this.groupsPath, groupName);
    const readmePath = join(groupPath, 'README.md');
    const resultsPath = join(groupPath, 'results.json');

    let resultsData = null;
    if (existsSync(resultsPath)) {
      try {
        resultsData = JSON.parse(readFileSync(resultsPath, 'utf-8'));
      } catch (error) {
        console.warn(`Failed to parse results for ${groupName}:`, error.message);
      }
    }

    let readme = `# ${groupNameDisplay}\n\n`;

    // Description
    readme += `${this.getGroupDescription(groupName)}\n\n`;

    // Performance Results
    if (resultsData && resultsData.files && resultsData.files.length > 0) {
      readme += this.generatePerformanceTable(resultsData);
    } else {
      readme += this.generateNoResultsSection(groupName);
    }

    // Available Tests
    readme += this.generateAvailableTestsSection(groupName, groupPath);

    // How to Run
    readme += this.generateHowToRunSection(groupName);

    // Technical Details
    readme += this.generateTechnicalDetailsSection(groupName);

    // Footer
    readme += `---\n`;
    readme += `*Last updated: ${new Date().toISOString()}*\n`;
    readme += `*Generated by: group-readme-generator.cjs*\n\n`;
    readme += `üîó [‚Üê Back to State Management Overview](../README.md)\n`;

    writeFileSync(readmePath, readme);
    console.log(`‚úÖ Generated README for ${groupNameDisplay}`);
  }

  getGroupDescription(groupName) {
    const descriptions = {
      'read': 'Performance benchmarks for state read operations across different scales and access patterns.',
      'write': 'Performance benchmarks for state write and mutation operations.',
      'form': 'Complex form state management benchmarks testing nested updates and field operations.',
      'async': 'Asynchronous state management benchmarks testing promise handling and data fetching patterns.',
      'memory': 'Memory usage and garbage collection benchmarks for state management libraries.',
      'cache': 'Memoization and caching performance benchmarks testing computed values and access patterns.',
      'spike': 'Performance spike testing to evaluate system behavior under sudden load changes.'
    };
    return descriptions[groupName] || `Performance benchmarks for ${groupName} operations.`;
  }

  generatePerformanceTable(resultsData) {
    let table = '';

    resultsData.files.forEach(file => {
      file.groups.forEach(group => {
        if (group.benchmarks && group.benchmarks.length > 0) {
          // Group benchmarks by test name (arena benchmark - all libraries compete in same test)
          const byTestName = {};
          group.benchmarks.forEach(bench => {
            // Extract test name (e.g., "Simple Read" from "Simple Read - Solid Signals")
            const testName = bench.name.split(' - ')[0];
            if (!byTestName[testName]) {
              byTestName[testName] = [];
            }
            byTestName[testName].push(bench);
          });

          // Display each test as an arena (all libraries compete)
          Object.entries(byTestName).forEach(([testName, benchmarks]) => {
            table += `## ${testName}\n\n`;

            // Sort libraries by performance for this test
            const sortedBenchmarks = benchmarks
              .filter(bench => bench.hz)
              .sort((a, b) => b.hz - a.hz);

            // Performance comparison chart
            if (sortedBenchmarks.length > 0) {
              const maxHz = sortedBenchmarks[0].hz;
              table += `**Performance Comparison:**\n\n`;

              sortedBenchmarks.slice(0, 3).forEach((bench, idx) => {
                const emoji = idx === 0 ? 'ü•á' : idx === 1 ? 'ü•à' : 'ü•â';
                const libraryName = this.formatLibraryName(bench.library);
                const barLength = Math.round((bench.hz / maxHz) * 20);
                const bar = '‚ñà'.repeat(barLength);
                const opsFormatted = (bench.hz / 1000000).toFixed(2);
                table += `${emoji} ${libraryName.padEnd(20)} ${bar.padEnd(20)} ${opsFormatted}M ops/sec\n`;
              });
              table += '\n';
            }

            // Detailed results table
            table += '| Rank | Library | Ops/sec | Variance | Mean | p99 | Samples |\n';
            table += '|------|---------|---------|----------|------|-----|----------|\n';

            sortedBenchmarks.forEach((bench, index) => {
              const rank = index + 1;
              const emoji = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : '';
              const rankDisplay = emoji || rank.toString();
              const libraryName = this.formatLibraryName(bench.library);
              const opsPerSec = bench.hz ? bench.hz.toLocaleString() : 'N/A';
              const variance = bench.rme ? `¬±${bench.rme.toFixed(2)}%` : 'N/A';
              const mean = bench.mean ? `${(bench.mean * 1000).toFixed(4)}ms` : 'N/A';
              const p99 = bench.p99 ? `${(bench.p99 * 1000).toFixed(4)}ms` : 'N/A';
              const samples = bench.samples ? bench.samples.toLocaleString() : 'N/A';

              table += `| ${rankDisplay} | **${libraryName}** | ${opsPerSec} | ${variance} | ${mean} | ${p99} | ${samples} |\n`;
            });

            // Add key insight
            if (sortedBenchmarks.length >= 2) {
              const fastest = sortedBenchmarks[0];
              const slowest = sortedBenchmarks[sortedBenchmarks.length - 1];
              const fastestName = this.formatLibraryName(fastest.library);
              const slowestName = this.formatLibraryName(slowest.library);
              const speedup = (fastest.hz / slowest.hz).toFixed(2);
              table += `\n**Key Insight:** ${fastestName} is ${speedup}x faster than ${slowestName} in this category.\n`;
            }

            table += '\n';
          });
        }
      });
    });

    return table;
  }

  formatLibraryName(library) {
    const nameMap = {
      'jotai': 'Jotai',
      'zustand': 'Zustand',
      'redux': 'Redux Toolkit',
      'redux-toolkit': 'Redux Toolkit',
      'mobx': 'MobX',
      'valtio': 'Valtio',
      'preact-signals': 'Preact Signals',
      'solid-signals': 'Solid Signals',
      'zen': 'Zen'
    };
    return nameMap[library] || library;
  }

  generateNoResultsSection(groupName) {
    return `## Performance Results\n\nNo benchmark results available yet.\n\nTo generate results:\n\n\`\`\bash\n# Run all ${groupName} benchmarks\nnpm run benchmark:${groupName}\n\n# Or run specific tests\nnode scripts/run-generated-tests.cjs ${groupName}-single.bench.ts\n\`\`\n\n`;
  }

  generateAvailableTestsSection(groupName, groupPath) {
    let section = `## Available Tests\n\n`;

    try {
      const testFiles = require('fs').readdirSync(groupPath)
        .filter(file => file.endsWith('.bench.ts'))
        .sort();

      if (testFiles.length > 0) {
        section += `### Test Files\n\n`;
        testFiles.forEach(file => {
          const testName = file.replace('.bench.ts', '');
          section += `- \`${testName}\` - Individual benchmark test\n`;
        });
      } else {
        section += `No test files found. Run the test generator first:\n\n`;
        section += `\`\`\bash\nnpx tsx scripts/test-generator.ts state-management\n\`\`\n\n`;
      }
    } catch (error) {
      section += `Error reading test files: ${error.message}\n`;
    }

    return section + '\n';
  }

  generateHowToRunSection(groupName) {
    return `## How to Run Tests\n\n### Quick Start\n\n\`\`\bash\n# Run all ${groupName} benchmarks\nnpm run benchmark:${groupName}\n\n# Run specific test\nnode scripts/run-generated-tests.cjs ${groupName}-single.bench.ts\n\n# Run all ${groupName} tests\nnode scripts/run-generated-tests.cjs ${groupName}-*.bench.ts\n\n# Use developer dashboard\nnode scripts/dev-dashboard.cjs\n\`\`\n\n### Available Commands\n\n\`\`\bash\nnpm run benchmark:${groupName}        # Run all ${groupName} tests\nnode scripts/run-generated-tests.cjs list # List all available tests\nnpx tsx scripts/test-generator.ts state-management # Regenerate tests\n\`\`\n\n`;
  }

  generateTechnicalDetailsSection(groupName) {
    const technicalInfo = {
      'read': {
        description: 'Read operations test the performance of state access patterns.',
        scales: ['Single', 'Burst', 'Moderate', 'High Frequency', 'Extreme'],
        focus: ['State access speed', 'Memory usage patterns', 'Computation overhead']
      },
      'write': {
        description: 'Write operations test state mutation and update performance.',
        scales: ['Single', 'Burst', 'Batch', 'Heavy'],
        focus: ['Mutation speed', 'Batch operations', 'State consistency']
      },
      'form': {
        description: 'Form state tests complex nested object manipulation.',
        scales: ['Simple', 'Nested', 'Complex'],
        focus: ['Nested updates', 'Object manipulation', 'Form validation patterns']
      },
      'async': {
        description: 'Async operations test promise handling and data fetching.',
        scales: ['Sequential', 'Concurrent', 'Heavy'],
        focus: ['Promise resolution', 'Async state updates', 'Loading states']
      },
      'memory': {
        description: 'Memory tests evaluate object creation and garbage collection.',
        scales: ['Light', 'Moderate', 'Heavy'],
        focus: ['Memory allocation', 'GC pressure', 'Object lifecycle']
      },
      'cache': {
        description: 'Cache tests evaluate memoization and computed value performance.',
        scales: ['Light Memo', 'Heavy Computation', 'Burst Access'],
        focus: ['Memoization efficiency', 'Computed values', 'Access patterns']
      },
      'spike': {
        description: 'Spike tests evaluate performance under sudden load changes.',
        scales: ['Gentle', 'Moderate', 'Severe', 'Extreme'],
        focus: ['Load handling', 'Recovery time', 'Performance degradation']
      }
    };

    const info = technicalInfo[groupName];
    if (!info) return '';

    let section = `## Technical Details\n\n`;
    section += `**Description**: ${info.description}\n\n`;

    if (info.scales) {
      section += `**Test Scales**: ${info.scales.map(s => `\`${s}\``).join(', ')}\n\n`;
    }

    if (info.focus) {
      section += `**Focus Areas**: ${info.focus.map(f => `- ${f}`).join('\n')}\n\n`;
    }

    section += `**Library Interface**: All libraries implement a standardized interface with these methods:\n`;
    section += ` \`get count\`, \`increment\`, \`setNested\`, \`addUser\`, etc.\n\n`;

    section += `**Measurement**: Each test runs multiple iterations and reports:\n`;
    section += `- Operations per second (ops/sec)\n`;
    section += `- Mean execution time\n`;
    section += `- 99th percentile (p99)\n`;
    section += `- Statistical variance\n\n`;

    return section;
  }

  generateAllGroups() {
    const groups = this.discoverGroups();

    groups.forEach(group => {
      this.generateGroupReadme(group, this.getDisplayName(group));
    });
  }

  discoverGroups() {
    const groups = [];

    try {
      const items = require('fs').readdirSync(this.groupsPath, { withFileTypes: true });
      items.forEach(item => {
        if (item.isDirectory() && !item.name.startsWith('.')) {
          groups.push(item.name);
        }
      });
    } catch (error) {
      console.error('Error discovering groups:', error.message);
    }

    return groups.sort();
  }

  getDisplayName(groupName) {
    const displayNames = {
      'read': 'Read Operations',
      'write': 'Write Operations',
      'form': 'Form State Management',
      'async': 'Async Operations',
      'memory': 'Memory Management',
      'cache': 'Cache Performance',
      'spike': 'Performance Spike Testing'
    };
    return displayNames[groupName] || groupName.charAt(0).toUpperCase() + groupName.slice(1);
  }
}

// CLI Interface
if (require.main === module) {
  const basePath = process.argv[2] || process.cwd();
  const groupsPath = join(basePath, 'groups');

  console.log('üìù Generating README files for all test groups...\n');

  const generator = new GroupReadmeGenerator(groupsPath);
  generator.generateAllGroups();

  console.log('\n‚úÖ All group README files generated!');
}

module.exports = GroupReadmeGenerator;