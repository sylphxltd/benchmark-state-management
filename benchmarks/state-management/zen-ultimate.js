var I=null,K=0,O=new Map,J=[];function Z(j,A,q){let B=j._listeners;if(!B)return;let G=B.length;for(let H=0;H<G;H++)B[H](A,q)}var P={get value(){if(I){let j=I._sources,A=!1,q=j.length;for(let B=0;B<q;B++)if(j[B]===this){A=!0;break}if(!A)j.push(this)}return this._value},set value(j){let A=this._value;if(j===A||j!==j&&A!==A)return;this._value=j;let q=this._listeners;if(q){let B=q.length;for(let G=0;G<B;G++){let H=q[G];if(H._computedZen)H._computedZen._dirty=!0}}if(K>0){if(!O.has(this))O.set(this,A)}else if(K++,Z(this,j,A),K--,J.length>0){let B=J.length;for(let G=0;G<B;G++)J[G]();J.length=0}}};function T(j){let A=Object.create(P);return A._kind="zen",A._value=j,A}function C(j,A){let q=j._kind==="zen"?j:j;if(!q._listeners)q._listeners=[];if(q._listeners.push(A),j._kind==="computed"&&j._unsubs===void 0)X(j);return A(q._value,void 0),()=>{let B=q._listeners;if(!B)return;let G=B.indexOf(A);if(G===-1)return;if(B.splice(G,1),B.length===0){if(q._listeners=void 0,j._kind==="computed"&&j._unsubs)$(j)}}}function R(j){K++;try{return j()}finally{if(K--,K===0){if(O.size>0){for(let[A,q]of O){let B=A._listeners;if(B){let G=A._value,H=B.length;for(let M=0;M<H;M++)B[M](G,q)}}O.clear()}if(J.length>0){let A=J.length;for(let q=0;q<A;q++)J[q]();J.length=0}}}}function _(j){let A=j._unsubs!==void 0;if(A)$(j),j._sources=[];let q=I;I=j;try{let B=j._calc();if(j._dirty=!1,A&&j._sources.length>0)X(j);if(j._value!==null&&(B===j._value||B!==B&&j._value!==j._value))return;let G=j._value;if(j._value=B,K>0){if(!O.has(j))O.set(j,G)}else Z(j,B,G)}finally{I=q}}function Q(j){let A=j.length;for(let q=0;q<A;q++)j[q]()}function W(j,A){let q=[],B=j.length;for(let G=0;G<B;G++){let H=j[G];if(!H._listeners)H._listeners=[];H._listeners.push(A),q.push(()=>{let M=H._listeners;if(!M)return;let Y=M.indexOf(A);if(Y!==-1)M.splice(Y,1)})}return q}function X(j){let A=()=>{j._dirty=!0,_(j)};A._computedZen=j,j._unsubs=W(j._sources,A)}function $(j){if(!j._unsubs)return;Q(j._unsubs),j._unsubs=void 0,j._dirty=!0}var v={get value(){if(I){let j=I._sources,A=!1,q=j.length;for(let B=0;B<q;B++)if(j[B]===this){A=!0;break}if(!A)j.push(this)}if(this._dirty){if(_(this),this._unsubs===void 0&&this._sources.length>0)X(this)}return this._value}};function U(j,A){let q=Object.create(v);return q._kind="computed",q._value=null,q._dirty=!0,q._sources=A||[],q._calc=j,q}function y(j){if(j._cancelled)return;if(j._queued=!1,j._cleanup){try{j._cleanup()}catch(q){}j._cleanup=void 0}if(j._autoTrack&&j._unsubs!==void 0)Q(j._unsubs),j._unsubs=void 0,j._sources=[];let A=I;if(j._autoTrack)I=j;try{let q=j._callback();if(q)j._cleanup=q}catch(q){}finally{I=A}if(!j._unsubs&&j._sources.length>0)j._unsubs=W(j._sources,()=>F(j))}function F(j){if(j._cancelled||j._queued)return;if(K>0){j._queued=!0,J.push(j._execute);return}y(j)}function m(j,A){let q={_sources:A||[],_callback:j,_cancelled:!1,_autoTrack:!A,_queued:!1,_execute:null};q._execute=()=>y(q);let B=I;if(q._autoTrack)I=q;try{let G=q._callback();if(G)q._cleanup=G}catch(G){}finally{I=B}if(q._sources.length>0)q._unsubs=W(q._sources,()=>F(q));return()=>{if(q._cancelled)return;if(q._cancelled=!0,q._cleanup)try{q._cleanup()}catch(G){}if(q._unsubs)Q(q._unsubs)}}export{T as zen,C as subscribe,m as effect,U as computed,R as batch};
